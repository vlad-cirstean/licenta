<psk-page title="Planning">
    <psk-toc title="PrivateSky Innovations"></psk-toc>

    <psk-chapter title="Swarm Communication ">

        <psk-chapter title="Exploration of the swarm communication and verifiable choreographies">
            <psk-link page="PrivateSky/swarms-explained">Swarm communication explained </psk-link>
        </psk-chapter>

        <psk-chapter title="Encrypted Choregraphies security model">
            Under the concept of "Encrypted Choregraphies" we propose a general model for handling cryptography primitives in swarms in general.
            <psk-link page="Development/encrypted-choreographies">Description of the Encrypted Choregraphies </psk-link>
        </psk-chapter>

        <psk-chapter title="Serverless Choregraphies ">
            Under the concept of "Serverless Choregraphies" we propose a general model for running executable choreographies in a "choreography as a service" model.
            We use this model also fo execution of the blockchain transactions.
            <psk-link page="Development/encrypted-choreographies">Description of the Serverless Choregraphies </psk-link>
        </psk-chapter>

    </psk-chapter>


    <psk-chapter title="Hierarchical Blockchain Arhitecture">
        A short presentation of blockchain architectures proposed by PrivateSky can be found here:  <psk-link page="PrivateSky/Architecture" > Architecture for Blockchain</psk-link>

        <psk-chapter title="Asset & transaction model">
            Documentation about the assets/transactions model is described  <psk-link page="PrivateSky/transactions" > here</psk-link>
        </psk-chapter>


        <psk-chapter title="OBFT consensus algorithm">
            OBFT consensus algorithm will be described <psk-link page="PrivateSky/obft" > here</psk-link>.
        </psk-chapter>


        <psk-chapter title="Anchored consensus algorithm">
            Anchored consensus algorithm will be described OBFT consensus algorithm will be described <psk-link page="PrivateSky/csb consensus" > here</psk-link>.
        </psk-chapter>
    </psk-chapter>

    <psk-chapter title="EDFS subproject">
        PrivateSky efforts to offer to create a database for storing private data conducted us to propose the  EDFS (Encrypted Distributed File System) that is both a file system and a blockchain based distributed database.
        The main purpose of EDFS is to serve as near-chain (off-chain) storage for blockchains.
        To properly understand EDFS capabilities we need to understand 4 concepts:  BAR archives,CSBs, Secret Smart Contracts, Self-Sovereign Applications.

        <psk-chapter title="BAR file format">
            A BAR is an archive format (to replace ZIP,TAR file formats) so is just a container for files.
            As a difference from the regular archives, BARs are created to follow this list of properties:
            <ol>
                <li>
                    BARs can be stored in files but also in cloud encrypted with a secret key that we call SEED.
                </li>
                <li>
                    A SEED is an encyption key but it is used to cryptographically derivate an identifier for the BAR archive. This identifier is called LSEED (Location Seed) and can be used to locate a BAR file.
                    The name of the file and the LSEED are called "Aliases".
                </li>

                <li>
                    BARs are stored in cloud as compressed Bricks. A large file is divided into Bricks. A Brick is just an encrypted buffer identifiable by its hash (after compression and encryption).
                    Each Brick is encrypted with a different gey (randomly generated)
                </li>
                <li>
                    A specific version of a BAR is identifiable by cryptographic hash  of it's content by computing the hash of the hashes of all its Bricks.
                </li>
            </ol>

            For storing those Bricks, we have created the EDFS storage service but we plan to have similar storages that are using various cloud storages (Dropbox , Google Drive, Amazon S3,IPFS, etc)

            <ul>
                Therefore a BAR is:
                <li>
                    An archive storable in cloud as Bricks
                </li>
                <li>
                    Anchorable in blockchains by it's HASH
                </li>

                <li>
                    Referencable in blockchain by an Alias
                </li>

                <li>
                    Retrievable from cloud by a SEED
                </li>
            </ul>


        </psk-chapter>

        <psk-chapter title="CSB concept">
            <ul>
                A CSB (Cloud Safe Box) is a BAR archive conatining
                <li> An embedded ledger (a blockchain as  chained history of transaction grouped in blocks) </li>
                <li> Constitution (code) </li>
            </ul>

            </div>
            All the embedded files are reflected by records in blockchain (called assets).
            </div>
            </div>
            The control on the blockchain records is guarded by blockchain transactions
            </div>
            </div>
            Embedded Web Applications are implemented without any servers (service workers)
            </div>
            <div>
                In a sense a CSB is a sidechain but not a usual one.    A CSB it is not a permanently online blockchain (Sidechain). We call it as an offline Sidechain.
                It is a new breed of blockchain: offline blockchains.  There are no online P2P nodes communicating between them all the time. We have only an “Indirect communication” by anchoring the new HASH of
                the BAR (A CSB is a BAR) in a blockchain and by adding new Bricks in the cloud storages.
            </div>
            <div>
                From the programmer perspective CSBs are self-refreshing archives that can be read or updated only in those nodes with access to the SEED (encryption key).
                The archive is containing a chained history of events (like in an event sourcing implemented as a blockchain) that at each self-refreshing moment are used
                for automated verification of the security and business rules.
                The verification and consensus happens “offline” like in “when needed to read or write” and all the history of events  (even invalid ones) remain stored as Bricks.
                If a node is writing wrong transactions, they will be ignored by the network.
            </div>

            <div>
                The consensus at the level of a CSB depends heavily on the consensus happening properly in the blockchain in which the CSB is anchored in. We can call it “anchored consensus”.
            </div>
        </psk-chapter>

        <psk-chapter title="Secret Smart Contracts">
            A set of related asset types and transactions types from the constitution of a CSB blockchain are called in PrivateSky with the term: Secret Smart Contracts.
            <ol>
                Key differences compared with smart contracts:
                <li>
                    Their existence is visible only to a small group of users (because they are embedded in CSBs)
                </li>
                <li>
                    Executed in security contexts: automatically use the secret keys available to the current user (keys stored in CSBs)
                </li>
                <li>
                    Verifiable only by a selected group
                </li>
            </ol>
        </psk-chapter>

        <psk-chapter title="Self-Sovereign Applications (SSApps)">
            Self-Sovereign Applications are quite similar with Progressive Web Applications because Service Workers are used.
            <div>
                A Service Worker is essentially a JavaScript file that runs separately from the main browser thread, intercepting network requests, caching or retrieving resources from the cache, and delivering push messages.
            </div>

            We are talking about SSApp as about a Distributed Application (DApp) implemented with tehnologies for Web Applications and in such a way that all its code and data is stored in CSBs.
            The UI and "server" side part of the SSApp stays in CSBs. The execution of SSApp happens without distant servers (there is no external server doing any processing!) but a server is simulated using service workers.

        </psk-chapter>

        Hopefully, we understand now how EDFS is a nice  programming abstraction to make it easier to work with encrypted and distributed data.
    </psk-chapter>


    <psk-chapter title="CardinalJs subproject">
        CardinalJs appeared as a method of programming the Ui of teh Self Sovereign Applications. Details can be found <psk-link page="Cardinal/web-components-mvc">here </psk-link>
    </psk-chapter>

    </psk-chapter>

    <psk-chapter title="CSB concept">
        <ul>
            A CSB (Cloud Safe Box) is a BAR archive conatining
            <li> An embedded ledger (a blockchain as  chained history of transaction grouped in blocks) </li>
            <li> Constitution (code) </li>
        </ul>

        </div>
        All the embedded files are reflected by records in blockchain (called assets).
        </div>
        </div>
        The control on the blockchain records is guarded by blockchain transactions
        </div>
        </div>
        Embedded Web Applications are implemented without any servers (service workers)
        </div>
        <div>
            In a sense a CSB is a sidechain but not a usual one.    A CSB it is not a permanently online blockchain (Sidechain). We call it as an offline Sidechain.
            It is a new breed of blockchain: offline blockchains.  There are no online P2P nodes communicating between them all the time. We have only an “Indirect communication” by anchoring the new HASH of
            the BAR (A CSB is a BAR) in a blockchain and by adding new Bricks in the cloud storages.
        </div>
        <div>
            From the programmer perspective CSBs are self-refreshing archives that can be read or updated only in those nodes with access to the SEED (encryption key).
            The archive is containing a chained history of events (like in an event sourcing implemented as a blockchain) that at each self-refreshing moment are used
            for automated verification of the security and business rules.
            The verification and consensus happens “offline” like in “when needed to read or write” and all the history of events  (even invalid ones) remain stored as Bricks.
            If a node is writing wrong transactions, they will be ignored by the network.
        </div>

        <div>
            The consensus at the level of a CSB depends heavily on the consensus happening properly in the blockchain in which the CSB is anchored in. We can call it “anchored consensus”.
        </div>
    </psk-chapter>

    <psk-chapter title="Secret Smart Contracts">
        A set of related asset types and transactions types from the constitution of a CSB blockchain are called in PrivateSky with the term: Secret Smart Contracts.
        <ol>
            Key differences compared with smart contracts:
            <li>
                Their existence is visible only to a small group of users (because they are embedded in CSBs)
            </li>
            <li>
                Executed in security contexts: automatically use the secret keys available to the current user (keys stored in CSBs)
            </li>
            <li>
                Verifiable only by a selected group
            </li>
        </ol>
    </psk-chapter>

    <psk-chapter title="Self-Sovereign Applications (SSApps)">
        Self-Sovereign Applications are quite similar with Progressive Web Applications because Service Workers are used.
        <div>
            A Service Worker is essentially a JavaScript file that runs separately from the main browser thread, intercepting network requests, caching or retrieving resources from the cache, and delivering push messages.
        </div>

        We are talking about SSApp as about a Distributed Application (DApp) implemented with tehnologies for Web Applications and in such a way that all its code and data is stored in CSBs.
        The UI and "server" side part of the SSApp stays in CSBs. The execution of SSApp happens without distant servers (there is no external server doing any processing!) but a server is simulated using service workers.

    </psk-chapter>

    Hopefully, we understand now how EDFS is a nice  programming abstraction to make it easier to work with encrypted and distributed data.
    </psk-chapter>


    <psk-chapter title="CardinalJs subproject">
        CardinalJs appeared as a method of programming the Ui of teh Self Sovereign Applications. Details can be found <psk-link page="Cardinal/web-components-mvc">here </psk-link>
    </psk-chapter>


    </psk-chapter>

    <psk-chapter title="CSB concept">
        <ul>
            A CSB (Cloud Safe Box) is a BAR archive conatining
            <li> An embedded ledger (a blockchain as  chained history of transaction grouped in blocks) </li>
            <li> Constitution (code) </li>
        </ul>

        </div>
        All the embedded files are reflected by records in blockchain (called assets).
        </div>
        </div>
        The control on the blockchain records is guarded by blockchain transactions
        </div>
        </div>
        Embedded Web Applications are implemented without any servers (service workers)
        </div>
        <div>
            In a sense a CSB is a sidechain but not a usual one.    A CSB it is not a permanently online blockchain (Sidechain). We call it as an offline Sidechain.
            It is a new breed of blockchain: offline blockchains.  There are no online P2P nodes communicating between them all the time. We have only an “Indirect communication” by anchoring the new HASH of
            the BAR (A CSB is a BAR) in a blockchain and by adding new Bricks in the cloud storages.
        </div>
        <div>
            From the programmer perspective CSBs are self-refreshing archives that can be read or updated only in those nodes with access to the SEED (encryption key).
            The archive is containing a chained history of events (like in an event sourcing implemented as a blockchain) that at each self-refreshing moment are used
            for automated verification of the security and business rules.
            The verification and consensus happens “offline” like in “when needed to read or write” and all the history of events  (even invalid ones) remain stored as Bricks.
            If a node is writing wrong transactions, they will be ignored by the network.
        </div>

        <div>
            The consensus at the level of a CSB depends heavily on the consensus happening properly in the blockchain in which the CSB is anchored in. We can call it “anchored consensus”.
        </div>
    </psk-chapter>

    <psk-chapter title="Secret Smart Contracts">
        A set of related asset types and transactions types from the constitution of a CSB blockchain are called in PrivateSky with the term: Secret Smart Contracts.
        <ol>
            Key differences compared with smart contracts:
            <li>
                Their existence is visible only to a small group of users (because they are embedded in CSBs)
            </li>
            <li>
                Executed in security contexts: automatically use the secret keys available to the current user (keys stored in CSBs)
            </li>
            <li>
                Verifiable only by a selected group
            </li>
        </ol>
    </psk-chapter>

    <psk-chapter title="Self-Sovereign Applications (SSApps)">
        Self-Sovereign Applications are quite similar with Progressive Web Applications because Service Workers are used.
        <div>
            A Service Worker is essentially a JavaScript file that runs separately from the main browser thread, intercepting network requests, caching or retrieving resources from the cache, and delivering push messages.
        </div>

        We are talking about SSApp as about a Distributed Application (DApp) implemented with tehnologies for Web Applications and in such a way that all its code and data is stored in CSBs.
        The UI and "server" side part of the SSApp stays in CSBs. The execution of SSApp happens without distant servers (there is no external server doing any processing!) but a server is simulated using service workers.

    </psk-chapter>

    Hopefully, we understand now how EDFS is a nice  programming abstraction to make it easier to work with encrypted and distributed data.
    </psk-chapter>


    <psk-chapter title="CardinalJs subproject">
        CardinalJs appeared as a method of programming the Ui of teh Self Sovereign Applications. Details can be found <psk-link page="Cardinal/web-components-mvc">here </psk-link>
    </psk-chapter>


    <psk-chapter title="Introduction">
        <psk-description>
            Conventional identity management systems are based on centralized authorities such as corporate directory services, certificate authorities, or domain name registries. From the standpoint of cryptographic trust verification, each of these centralized authorities serves as its own root of trust. To make identity management work across these systems requires implementing federated identity management.

            The emergence of distributed ledger technology (DLT) and blockchain technology provides the opportunity for fully decentralized identity management. In a decentralized identity system, entities (that is, discrete identifiable units such as, but not limited to, people, organizations, and things) are free to use any shared root of trust. Globally distributed ledgers, decentralized P2P networks, or other systems with similar capabilities, provide the means for managing a root of trust without introducing a centralized authority or a single point of failure. In combination, DLTs and decentralized identity management systems enable any entity to create and manage their own identifiers on any number of distributed, independent roots of trust.

            Entities are identified by decentralized identifiers (DIDs), and can authenticate using proofs (for example, digital signatures, privacy-preserving biometric protocols, and so on). DIDs point to DID documents. A DID document contains a set of service endpoints for interacting with the entity that the DID identifies (that is, the DID subject). Following the guidelines of Privacy by Design, any entity can have as many DIDs (and corresponding DID documents and service endpoints) as necessary to respect the entity’s desired separation of identities, personas, and contexts (in the everyday sense of these words).

            DID methods are the mechanism by which a DID and its associated DID document are created, read, updated, and deactivated on a specific distributed ledger or network. DID methods are defined using separate DID method specifications.

            This design eliminates dependence on centralized registries for identifiers as well as centralized certificate authorities for key management, which is the standard in hierarchical PKI (public key infrastructure). In cases where the DID registry is a distributed ledger, each entity can serve as its own root authority. This architecture is referred to as DPKI (decentralized PKI).
        </psk-description>



        <psk-chapter title="A Simple Example">
            This section is non-normative.

            A DID is a simple text string consisting of three parts, the:
            <psk-list>
                URL scheme identifier (did)
                Identifier for the DID method
                DID method-specific identifier.
            </psk-list>
        </psk-chapter>

        <psk-chapter title="Design Goals">

            <psk-description>
                Decentralized Identifiers are a component of larger systems, such as the Verifiable Credentials ecosystem [VC-DATA-MODEL], which drove the design goals for this specification. This section summarizes the primary design goals for this specification.
            </psk-description>
            <psk-list>
                URL scheme identifier (did)
                Identifier for the DID method
                DID method-specific identifier.
            </psk-list>

            <psk-table header="true">
                Goal | Description
                Decentralization | Eliminate the requirement for centralized authorities or single point failure in identifier management, including the registration of globally unique identifiers, public verification keys, service endpoints, and other metadata.
                Control	| Give entities, both human and non-human, the power to directly control their digital identifiers without the need to rely on external authorities.
                Privacy	| Enable entities to control the privacy of their information, including minimal, selective, and progressive disclosure of attributes or other data.
                Security |	Enable sufficient security for relying parties to depend on DID documents for their required level of assurance.
            </psk-table>
        </psk-chapter>


    </psk-chapter>

    <psk-chapter title="Terminology">
        <psk-description>
            This document attempts to communicate the concepts outlined in the decentralized identifier space by using specialized terms to discuss specific concepts. This terminology is included below and linked to throughout the document to aid the reader:
        </psk-description>
    </psk-chapter>

    <psk-chapter title="Overall Architecture">
        <psk-description>
            This document attempts to communicate the concepts outlined in the decentralized identifier space by using specialized terms to discuss specific concepts. This terminology is included below and linked to throughout the document to aid the reader:
        </psk-description>

        <psk-chapter title="DIDs">

        </psk-chapter>

        <psk-chapter title="DID Registries">

        </psk-chapter>

        <psk-chapter title="DID Documents">
            <psk-description>
                A DID document is the resource that is associated with a decentralized identifier (DID). DID documents typically express verification methods (such as public keys) and services that can be used to interact with a DID controller.

                A DID document is serialized according to a particular syntax, as outlined in Section § 8. Core Representations). The DID itself is contained in the id property.

                The properties that can be present in a DID document are outlined in Section § 3.3 DID Documents.

                The properties present in a DID document can be updated according to the applicable operations outlined in Section § 9. Methods.
            </psk-description>
        </psk-chapter>
    </psk-chapter>

    <psk-chapter title="Identifier">

        <psk-description>
            The concept of a globally unique decentralized identifier is not new. Universally Unique Identifiers (UUIDs) were first developed in the 1980s and later became a standard feature of the Open Software Foundation’s Distributed Computing Environment. UUIDs achieve global uniqueness without a centralized registry service by using an algorithm that generates 128-bit values with sufficient entropy that the chance of collision are infinitesimally small. UUIDs are formally specified in [RFC4122] as a specific type of Unified Resource Name (URN).
        </psk-description>
        A DID is similar to a UUID except that:

        <psk-list>
            Like a URL, it can be resolved or dereferenced to a standard resource describing the subject. That is, a DID document. For more information, see Section § 3.3 DID Documents.
            Unlike most resources returned when dereferencing URLs, a DID document usually contains cryptographic material enabling authentication of the DID subject.
        </psk-list>

        <psk-chapter title="DID Syntax">
            <psk-chapter title="Generic DID Syntax">
                The generic DID scheme is a URI scheme conformant with [RFC3986].
                The following is the ABNF definition using the syntax in [RFC5234], which defines ALPHA and DIGIT. All other rule names not defined in this ABNF are defined in [RFC3986].
            </psk-chapter>


            <psk-highlight title="Issue" type-of-highlight="issue">
                This document is undergoing a major structural refactoring and will not be easy to read. A previously published version that has a better topical flow may be a better read for people new to this work. When this document has been updated to have a better flow, this comment will be removed.
            </psk-highlight>

            The generic DID scheme is a URI scheme conformant with [RFC3986].
            <psk-highlight title="Note" type-of-highlight="note">
                A DID always identifies the DID subject.
            </psk-highlight>

        </psk-chapter>

        <psk-chapter title="Method-Specific DID URL Parameters">
            <psk-description>
                A DID method specification MAY specify additional method-specific parameter names. A method-specific parameter name MUST be prefixed by the method name, as defined by the method-name rule.
                For example, if the method did:foo: defines the parameter bar, the parameter name must be foo:bar. An example DID URL using this method and this method-specific parameter would be as shown below.
            </psk-description>

            <psk-highlight title="Example 1" type-of-highlight="example">
                <code>
                    did:foo:21tDAKCERh95uGgKbJNHYp;foo:bar=high
                </code>
            </psk-highlight>

            <psk-highlight title="Example 2" type-of-highlight="example">
                <psk-code language="json">
                    {
                    "@context": "https://www.w3.org/ns/did/v1",
                    "id": "did:example:123456789abcdefghi",
                    "publicKey": [{
                    "id": "did:example:123456789abcdefghi#key-1",
                    "type": "RsaVerificationKey2018",
                    "controller": "did:example:123456789abcdefghi",
                    "publicKeyPem": "-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\r\n"
                    }, ...],
                    "authentication": [

                    "#key-1"
                    ]
                    }
                </psk-code>
            </psk-highlight>

        </psk-chapter>

    </psk-chapter>

    <psk-chapter title="DID Syntax">
        <psk-chapter title="Generic DID Syntax">
            The generic DID scheme is a URI scheme conformant with [RFC3986].
            The following is the ABNF definition using the syntax in [RFC5234], which defines ALPHA and DIGIT. All other rule names not defined in this ABNF are defined in [RFC3986].
        </psk-chapter>


        <psk-highlight title="Issue" type-of-highlight="issue">
            This document is undergoing a major structural refactoring and will not be easy to read. A previously published version that has a better topical flow may be a better read for people new to this work. When this document has been updated to have a better flow, this comment will be removed.
        </psk-highlight>

        The generic DID scheme is a URI scheme conformant with [RFC3986].
        <psk-highlight title="Note" type-of-highlight="note">
            A DID always identifies the DID subject.
        </psk-highlight>

    </psk-chapter>

    <psk-chapter title="DID Syntax">
        <psk-chapter title="Generic DID Syntax">
            The generic DID scheme is a URI scheme conformant with [RFC3986].
            The following is the ABNF definition using the syntax in [RFC5234], which defines ALPHA and DIGIT. All other rule names not defined in this ABNF are defined in [RFC3986].
        </psk-chapter>


        <psk-highlight title="Issue" type-of-highlight="issue">
            This document is undergoing a major structural refactoring and will not be easy to read. A previously published version that has a better topical flow may be a better read for people new to this work. When this document has been updated to have a better flow, this comment will be removed.
        </psk-highlight>

        The generic DID scheme is a URI scheme conformant with [RFC3986].
        <psk-highlight title="Note" type-of-highlight="note">
            A DID always identifies the DID subject.
        </psk-highlight>

    </psk-chapter>

    <psk-chapter title="DID Syntax">
        <psk-chapter title="Generic DID Syntax">
            The generic DID scheme is a URI scheme conformant with [RFC3986].
            The following is the ABNF definition using the syntax in [RFC5234], which defines ALPHA and DIGIT. All other rule names not defined in this ABNF are defined in [RFC3986].
        </psk-chapter>


        <psk-highlight title="Issue" type-of-highlight="issue">
            This document is undergoing a major structural refactoring and will not be easy to read. A previously published version that has a better topical flow may be a better read for people new to this work. When this document has been updated to have a better flow, this comment will be removed.
        </psk-highlight>

        The generic DID scheme is a URI scheme conformant with [RFC3986].
        <psk-highlight title="Note" type-of-highlight="note">
            A DID always identifies the DID subject.
        </psk-highlight>

    </psk-chapter>

    <psk-chapter title="DID Syntax">
        <psk-chapter title="Generic DID Syntax">
            The generic DID scheme is a URI scheme conformant with [RFC3986].
            The following is the ABNF definition using the syntax in [RFC5234], which defines ALPHA and DIGIT. All other rule names not defined in this ABNF are defined in [RFC3986].
        </psk-chapter>


        <psk-highlight title="Issue" type-of-highlight="issue">
            This document is undergoing a major structural refactoring and will not be easy to read. A previously published version that has a better topical flow may be a better read for people new to this work. When this document has been updated to have a better flow, this comment will be removed.
        </psk-highlight>

        The generic DID scheme is a URI scheme conformant with [RFC3986].
        <psk-highlight title="Note" type-of-highlight="note">
            A DID always identifies the DID subject.
        </psk-highlight>

    </psk-chapter>

    <psk-chapter title="DID Syntax">
        <psk-chapter title="Generic DID Syntax">
            The generic DID scheme is a URI scheme conformant with [RFC3986].
            The following is the ABNF definition using the syntax in [RFC5234], which defines ALPHA and DIGIT. All other rule names not defined in this ABNF are defined in [RFC3986].
        </psk-chapter>

        <psk-highlight title="Issue" type-of-highlight="issue">
            This document is undergoing a major structural refactoring and will not be easy to read. A previously published version that has a better topical flow may be a better read for people new to this work. When this document has been updated to have a better flow, this comment will be removed.
        </psk-highlight>

        The generic DID scheme is a URI scheme conformant with [RFC3986].
        <psk-highlight type-of-highlight="note">
            A DID always identifies the DID subject.
        </psk-highlight>

        <psk-chapter title="Generic DID Syntax with a very long and boring title">
            The generic DID scheme is a URI scheme conformant with [RFC3986].
            The following is the ABNF definition using the syntax in [RFC5234], which defines ALPHA and DIGIT. All other rule names not defined in this ABNF are defined in [RFC3986].
        </psk-chapter>

        <psk-chapter title="Generic DID Syntax with medium title">
            The generic DID scheme is a URI scheme conformant with [RFC3986].
            The following is the ABNF definition using the syntax in [RFC5234], which defines ALPHA and DIGIT. All other rule names not defined in this ABNF are defined in [RFC3986].
        </psk-chapter>

        <psk-chapter title="Generic DID Syntax with a very long and boring title that is never ending to tell you the story">
            The generic DID scheme is a URI scheme conformant with [RFC3986].
            The following is the ABNF definition using the syntax in [RFC5234], which defines ALPHA and DIGIT. All other rule names not defined in this ABNF are defined in [RFC3986].
        </psk-chapter>


    </psk-chapter>



    <psk-chapter title="Swarm Communication ">

        <psk-chapter title="Exploration of the swarm communication and verifiable choreographies">
            <psk-link page="PrivateSky/swarms-explained">Swarm communication explained </psk-link>
        </psk-chapter>

        <psk-chapter title="Encrypted Choregraphies security model">
            Under the concept of "Encrypted Choregraphies" we propose a general model for handling cryptography primitives in swarms in general.
            <psk-link page="Development/encrypted-choreographies">Description of the Encrypted Choregraphies </psk-link>
        </psk-chapter>

        <psk-chapter title="Serverless Choregraphies ">
            Under the concept of "Serverless Choregraphies" we propose a general model for running executable choreographies in a "choreography as a service" model.
            We use this model also fo execution of the blockchain transactions.
            <psk-link page="Development/encrypted-choreographies">Description of the Serverless Choregraphies </psk-link>
        </psk-chapter>

    </psk-chapter>


    <psk-chapter title="Hierarchical Blockchain Arhitecture">
        A short presentation of blockchain architectures proposed by PrivateSky can be found here:  <psk-link page="PrivateSky/Architecture" > Architecture for Blockchain</psk-link>

        <psk-chapter title="Asset & transaction model">
            Documentation about the assets/transactions model is described  <psk-link page="PrivateSky/transactions" > here</psk-link>
        </psk-chapter>


        <psk-chapter title="OBFT consensus algorithm">
            OBFT consensus algorithm will be described <psk-link page="PrivateSky/obft" > here</psk-link>.
        </psk-chapter>


        <psk-chapter title="Anchored consensus algorithm">
            Anchored consensus algorithm will be described OBFT consensus algorithm will be described <psk-link page="PrivateSky/csb consensus" > here</psk-link>.
        </psk-chapter>
    </psk-chapter>

    <psk-chapter title="EDFS subproject">

        PrivateSky efforts to offer to create a database for storing private data conducted us to propose the  EDFS (Encrypted Distributed File System) that is both a file system and a blockchain based distributed database.
        The main purpose of EDFS is to serve as near-chain (off-chain) storage for blockchains.
        To properly understand EDFS capabilities we need to understand 4 concepts:  BAR archives,CSBs, Secret Smart Contracts, Self-Sovereign Applications.

        <psk-chapter title="BAR file format">
            A BAR is an archive format (to replace ZIP,TAR file formats) so is just a container for files.
            As a difference from the regular archives, BARs are created to follow this list of properties:
            <ol>
                <li>
                    BARs can be stored in files but also in cloud encrypted with a secret key that we call SEED.
                </li>
                <li>
                    A SEED is an encyption key but it is used to cryptographically derivate an identifier for the BAR archive. This identifier is called LSEED (Location Seed) and can be used to locate a BAR file.
                    The name of the file and the LSEED are called "Aliases".
                </li>

                <li>
                    BARs are stored in cloud as compressed Bricks. A large file is divided into Bricks. A Brick is just an encrypted buffer identifiable by its hash (after compression and encryption).
                    Each Brick is encrypted with a different gey (randomly generated)
                </li>
                <li>
                    A specific version of a BAR is identifiable by cryptographic hash  of it's content by computing the hash of the hashes of all its Bricks.
                </li>
            </ol>

            For storing those Bricks, we have created the EDFS storage service but we plan to have similar storages that are using various cloud storages (Dropbox , Google Drive, Amazon S3,IPFS, etc)

            <ul>
                Therefore a BAR is:
                <li>
                    An archive storable in cloud as Bricks
                </li>
                <li>
                    Anchorable in blockchains by it's HASH
                </li>

                <li>
                    Referencable in blockchain by an Alias
                </li>

                <li>
                    Retrievable from cloud by a SEED
                </li>
            </ul>


        </psk-chapter>

        <psk-chapter title="CSB concept">
            <ul>
                A CSB (Cloud Safe Box) is a BAR archive conatining
                <li> An embedded ledger (a blockchain as  chained history of transaction grouped in blocks) </li>
                <li> Constitution (code) </li>
            </ul>

            </div>
            All the embedded files are reflected by records in blockchain (called assets).
            </div>
            </div>
            The control on the blockchain records is guarded by blockchain transactions
            </div>
            </div>
            Embedded Web Applications are implemented without any servers (service workers)
            </div>
            <div>
                In a sense a CSB is a sidechain but not a usual one.    A CSB it is not a permanently online blockchain (Sidechain). We call it as an offline Sidechain.
                It is a new breed of blockchain: offline blockchains.  There are no online P2P nodes communicating between them all the time. We have only an “Indirect communication” by anchoring the new HASH of
                the BAR (A CSB is a BAR) in a blockchain and by adding new Bricks in the cloud storages.
            </div>
            <div>
                From the programmer perspective CSBs are self-refreshing archives that can be read or updated only in those nodes with access to the SEED (encryption key).
                The archive is containing a chained history of events (like in an event sourcing implemented as a blockchain) that at each self-refreshing moment are used
                for automated verification of the security and business rules.
                The verification and consensus happens “offline” like in “when needed to read or write” and all the history of events  (even invalid ones) remain stored as Bricks.
                If a node is writing wrong transactions, they will be ignored by the network.
            </div>

            <div>
                The consensus at the level of a CSB depends heavily on the consensus happening properly in the blockchain in which the CSB is anchored in. We can call it “anchored consensus”.
            </div>
        </psk-chapter>

        <psk-chapter title="Secret Smart Contracts">
            A set of related asset types and transactions types from the constitution of a CSB blockchain are called in PrivateSky with the term: Secret Smart Contracts.
            <ol>
                Key differences compared with smart contracts:
                <li>
                    Their existence is visible only to a small group of users (because they are embedded in CSBs)
                </li>
                <li>
                    Executed in security contexts: automatically use the secret keys available to the current user (keys stored in CSBs)
                </li>
                <li>
                    Verifiable only by a selected group
                </li>
            </ol>
        </psk-chapter>

        <psk-chapter title="Self-Sovereign Applications (SSApps)">
            Self-Sovereign Applications are quite similar with Progressive Web Applications because Service Workers are used.
            <div>
                A Service Worker is essentially a JavaScript file that runs separately from the main browser thread, intercepting network requests, caching or retrieving resources from the cache, and delivering push messages.
            </div>

            We are talking about SSApp as about a Distributed Application (DApp) implemented with tehnologies for Web Applications and in such a way that all its code and data is stored in CSBs.
            The UI and "server" side part of the SSApp stays in CSBs. The execution of SSApp happens without distant servers (there is no external server doing any processing!) but a server is simulated using service workers.

        </psk-chapter>

        Hopefully, we understand now how EDFS is a nice  programming abstraction to make it easier to work with encrypted and distributed data.
    </psk-chapter>


    <psk-chapter title="CardinalJs subproject">
        CardinalJs appeared as a method of programming the Ui of teh Self Sovereign Applications. Details can be found <psk-link page="Cardinal/web-components-mvc">here </psk-link>
    </psk-chapter>

    </psk-chapter>

    <psk-chapter title="CSB concept">
        <ul>
            A CSB (Cloud Safe Box) is a BAR archive conatining
            <li> An embedded ledger (a blockchain as  chained history of transaction grouped in blocks) </li>
            <li> Constitution (code) </li>
        </ul>

        </div>
        All the embedded files are reflected by records in blockchain (called assets).
        </div>
        </div>
        The control on the blockchain records is guarded by blockchain transactions
        </div>
        </div>
        Embedded Web Applications are implemented without any servers (service workers)
        </div>
        <div>
            In a sense a CSB is a sidechain but not a usual one.    A CSB it is not a permanently online blockchain (Sidechain). We call it as an offline Sidechain.
            It is a new breed of blockchain: offline blockchains.  There are no online P2P nodes communicating between them all the time. We have only an “Indirect communication” by anchoring the new HASH of
            the BAR (A CSB is a BAR) in a blockchain and by adding new Bricks in the cloud storages.
        </div>
        <div>
            From the programmer perspective CSBs are self-refreshing archives that can be read or updated only in those nodes with access to the SEED (encryption key).
            The archive is containing a chained history of events (like in an event sourcing implemented as a blockchain) that at each self-refreshing moment are used
            for automated verification of the security and business rules.
            The verification and consensus happens “offline” like in “when needed to read or write” and all the history of events  (even invalid ones) remain stored as Bricks.
            If a node is writing wrong transactions, they will be ignored by the network.
        </div>

        <div>
            The consensus at the level of a CSB depends heavily on the consensus happening properly in the blockchain in which the CSB is anchored in. We can call it “anchored consensus”.
        </div>
    </psk-chapter>

    <psk-chapter title="Secret Smart Contracts">
        A set of related asset types and transactions types from the constitution of a CSB blockchain are called in PrivateSky with the term: Secret Smart Contracts.
        <ol>
            Key differences compared with smart contracts:
            <li>
                Their existence is visible only to a small group of users (because they are embedded in CSBs)
            </li>
            <li>
                Executed in security contexts: automatically use the secret keys available to the current user (keys stored in CSBs)
            </li>
            <li>
                Verifiable only by a selected group
            </li>
        </ol>
    </psk-chapter>

    <psk-chapter title="Self-Sovereign Applications (SSApps)">
        Self-Sovereign Applications are quite similar with Progressive Web Applications because Service Workers are used.
        <div>
            A Service Worker is essentially a JavaScript file that runs separately from the main browser thread, intercepting network requests, caching or retrieving resources from the cache, and delivering push messages.
        </div>

        We are talking about SSApp as about a Distributed Application (DApp) implemented with tehnologies for Web Applications and in such a way that all its code and data is stored in CSBs.
        The UI and "server" side part of the SSApp stays in CSBs. The execution of SSApp happens without distant servers (there is no external server doing any processing!) but a server is simulated using service workers.

    </psk-chapter>

    Hopefully, we understand now how EDFS is a nice  programming abstraction to make it easier to work with encrypted and distributed data.
    </psk-chapter>


    <psk-chapter title="CardinalJs subproject">
        CardinalJs appeared as a method of programming the Ui of teh Self Sovereign Applications. Details can be found <psk-link page="Cardinal/web-components-mvc">here </psk-link>
    </psk-chapter>


    </psk-chapter>

    <psk-chapter title="CSB concept">
        <ul>
            A CSB (Cloud Safe Box) is a BAR archive conatining
            <li> An embedded ledger (a blockchain as  chained history of transaction grouped in blocks) </li>
            <li> Constitution (code) </li>
        </ul>

        </div>
        All the embedded files are reflected by records in blockchain (called assets).
        </div>
        </div>
        The control on the blockchain records is guarded by blockchain transactions
        </div>
        </div>
        Embedded Web Applications are implemented without any servers (service workers)
        </div>
        <div>
            In a sense a CSB is a sidechain but not a usual one.    A CSB it is not a permanently online blockchain (Sidechain). We call it as an offline Sidechain.
            It is a new breed of blockchain: offline blockchains.  There are no online P2P nodes communicating between them all the time. We have only an “Indirect communication” by anchoring the new HASH of
            the BAR (A CSB is a BAR) in a blockchain and by adding new Bricks in the cloud storages.
        </div>
        <div>
            From the programmer perspective CSBs are self-refreshing archives that can be read or updated only in those nodes with access to the SEED (encryption key).
            The archive is containing a chained history of events (like in an event sourcing implemented as a blockchain) that at each self-refreshing moment are used
            for automated verification of the security and business rules.
            The verification and consensus happens “offline” like in “when needed to read or write” and all the history of events  (even invalid ones) remain stored as Bricks.
            If a node is writing wrong transactions, they will be ignored by the network.
        </div>

        <div>
            The consensus at the level of a CSB depends heavily on the consensus happening properly in the blockchain in which the CSB is anchored in. We can call it “anchored consensus”.
        </div>
    </psk-chapter>

    <psk-chapter title="Secret Smart Contracts">
        A set of related asset types and transactions types from the constitution of a CSB blockchain are called in PrivateSky with the term: Secret Smart Contracts.
        <ol>
            Key differences compared with smart contracts:
            <li>
                Their existence is visible only to a small group of users (because they are embedded in CSBs)
            </li>
            <li>
                Executed in security contexts: automatically use the secret keys available to the current user (keys stored in CSBs)
            </li>
            <li>
                Verifiable only by a selected group
            </li>
        </ol>
    </psk-chapter>

    <psk-chapter title="Self-Sovereign Applications (SSApps)">
        Self-Sovereign Applications are quite similar with Progressive Web Applications because Service Workers are used.
        <div>
            A Service Worker is essentially a JavaScript file that runs separately from the main browser thread, intercepting network requests, caching or retrieving resources from the cache, and delivering push messages.
        </div>

        We are talking about SSApp as about a Distributed Application (DApp) implemented with tehnologies for Web Applications and in such a way that all its code and data is stored in CSBs.
        The UI and "server" side part of the SSApp stays in CSBs. The execution of SSApp happens without distant servers (there is no external server doing any processing!) but a server is simulated using service workers.

    </psk-chapter>

    Hopefully, we understand now how EDFS is a nice  programming abstraction to make it easier to work with encrypted and distributed data.
    </psk-chapter>


    <psk-chapter title="CardinalJs subproject">
        CardinalJs appeared as a method of programming the Ui of teh Self Sovereign Applications. Details can be found <psk-link page="Cardinal/web-components-mvc">here </psk-link>
    </psk-chapter>


    <psk-chapter title="Introduction">
        <psk-description>
            Conventional identity management systems are based on centralized authorities such as corporate directory services, certificate authorities, or domain name registries. From the standpoint of cryptographic trust verification, each of these centralized authorities serves as its own root of trust. To make identity management work across these systems requires implementing federated identity management.

            The emergence of distributed ledger technology (DLT) and blockchain technology provides the opportunity for fully decentralized identity management. In a decentralized identity system, entities (that is, discrete identifiable units such as, but not limited to, people, organizations, and things) are free to use any shared root of trust. Globally distributed ledgers, decentralized P2P networks, or other systems with similar capabilities, provide the means for managing a root of trust without introducing a centralized authority or a single point of failure. In combination, DLTs and decentralized identity management systems enable any entity to create and manage their own identifiers on any number of distributed, independent roots of trust.

            Entities are identified by decentralized identifiers (DIDs), and can authenticate using proofs (for example, digital signatures, privacy-preserving biometric protocols, and so on). DIDs point to DID documents. A DID document contains a set of service endpoints for interacting with the entity that the DID identifies (that is, the DID subject). Following the guidelines of Privacy by Design, any entity can have as many DIDs (and corresponding DID documents and service endpoints) as necessary to respect the entity’s desired separation of identities, personas, and contexts (in the everyday sense of these words).

            DID methods are the mechanism by which a DID and its associated DID document are created, read, updated, and deactivated on a specific distributed ledger or network. DID methods are defined using separate DID method specifications.

            This design eliminates dependence on centralized registries for identifiers as well as centralized certificate authorities for key management, which is the standard in hierarchical PKI (public key infrastructure). In cases where the DID registry is a distributed ledger, each entity can serve as its own root authority. This architecture is referred to as DPKI (decentralized PKI).
        </psk-description>



        <psk-chapter title="A Simple Example">
            This section is non-normative.

            A DID is a simple text string consisting of three parts, the:
            <psk-list>
                URL scheme identifier (did)
                Identifier for the DID method
                DID method-specific identifier.
            </psk-list>
        </psk-chapter>

        <psk-chapter title="Design Goals">

            <psk-description>
                Decentralized Identifiers are a component of larger systems, such as the Verifiable Credentials ecosystem [VC-DATA-MODEL], which drove the design goals for this specification. This section summarizes the primary design goals for this specification.
            </psk-description>
            <psk-list>
                URL scheme identifier (did)
                Identifier for the DID method
                DID method-specific identifier.
            </psk-list>

            <psk-table header="true">
                Goal | Description
                Decentralization | Eliminate the requirement for centralized authorities or single point failure in identifier management, including the registration of globally unique identifiers, public verification keys, service endpoints, and other metadata.
                Control	| Give entities, both human and non-human, the power to directly control their digital identifiers without the need to rely on external authorities.
                Privacy	| Enable entities to control the privacy of their information, including minimal, selective, and progressive disclosure of attributes or other data.
                Security |	Enable sufficient security for relying parties to depend on DID documents for their required level of assurance.
            </psk-table>
        </psk-chapter>


    </psk-chapter>

    <psk-chapter title="Terminology">
        <psk-description>
            This document attempts to communicate the concepts outlined in the decentralized identifier space by using specialized terms to discuss specific concepts. This terminology is included below and linked to throughout the document to aid the reader:
        </psk-description>
    </psk-chapter>

    <psk-chapter title="Overall Architecture">
        <psk-description>
            This document attempts to communicate the concepts outlined in the decentralized identifier space by using specialized terms to discuss specific concepts. This terminology is included below and linked to throughout the document to aid the reader:
        </psk-description>

        <psk-chapter title="DIDs">

        </psk-chapter>

        <psk-chapter title="DID Registries">

        </psk-chapter>

        <psk-chapter title="DID Documents">
            <psk-description>
                A DID document is the resource that is associated with a decentralized identifier (DID). DID documents typically express verification methods (such as public keys) and services that can be used to interact with a DID controller.

                A DID document is serialized according to a particular syntax, as outlined in Section § 8. Core Representations). The DID itself is contained in the id property.

                The properties that can be present in a DID document are outlined in Section § 3.3 DID Documents.

                The properties present in a DID document can be updated according to the applicable operations outlined in Section § 9. Methods.
            </psk-description>
        </psk-chapter>
    </psk-chapter>

    <psk-chapter title="Identifier">

        <psk-description>
            The concept of a globally unique decentralized identifier is not new. Universally Unique Identifiers (UUIDs) were first developed in the 1980s and later became a standard feature of the Open Software Foundation’s Distributed Computing Environment. UUIDs achieve global uniqueness without a centralized registry service by using an algorithm that generates 128-bit values with sufficient entropy that the chance of collision are infinitesimally small. UUIDs are formally specified in [RFC4122] as a specific type of Unified Resource Name (URN).
        </psk-description>
        A DID is similar to a UUID except that:

        <psk-list>
            Like a URL, it can be resolved or dereferenced to a standard resource describing the subject. That is, a DID document. For more information, see Section § 3.3 DID Documents.
            Unlike most resources returned when dereferencing URLs, a DID document usually contains cryptographic material enabling authentication of the DID subject.
        </psk-list>

        <psk-chapter title="DID Syntax">
            <psk-chapter title="Generic DID Syntax">
                The generic DID scheme is a URI scheme conformant with [RFC3986].
                The following is the ABNF definition using the syntax in [RFC5234], which defines ALPHA and DIGIT. All other rule names not defined in this ABNF are defined in [RFC3986].
            </psk-chapter>


            <psk-highlight title="Issue" type-of-highlight="issue">
                This document is undergoing a major structural refactoring and will not be easy to read. A previously published version that has a better topical flow may be a better read for people new to this work. When this document has been updated to have a better flow, this comment will be removed.
            </psk-highlight>

            The generic DID scheme is a URI scheme conformant with [RFC3986].
            <psk-highlight title="Note" type-of-highlight="note">
                A DID always identifies the DID subject.
            </psk-highlight>

        </psk-chapter>

        <psk-chapter title="Method-Specific DID URL Parameters">
            <psk-description>
                A DID method specification MAY specify additional method-specific parameter names. A method-specific parameter name MUST be prefixed by the method name, as defined by the method-name rule.
                For example, if the method did:foo: defines the parameter bar, the parameter name must be foo:bar. An example DID URL using this method and this method-specific parameter would be as shown below.
            </psk-description>

            <psk-highlight title="Example 1" type-of-highlight="example">
                <code>
                    did:foo:21tDAKCERh95uGgKbJNHYp;foo:bar=high
                </code>
            </psk-highlight>

            <psk-highlight title="Example 2" type-of-highlight="example">
                <psk-code language="json">
                    {
                    "@context": "https://www.w3.org/ns/did/v1",
                    "id": "did:example:123456789abcdefghi",
                    "publicKey": [{
                    "id": "did:example:123456789abcdefghi#key-1",
                    "type": "RsaVerificationKey2018",
                    "controller": "did:example:123456789abcdefghi",
                    "publicKeyPem": "-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\r\n"
                    }, ...],
                    "authentication": [

                    "#key-1"
                    ]
                    }
                </psk-code>
            </psk-highlight>

        </psk-chapter>

    </psk-chapter>

    <psk-chapter title="DID Syntax">
        <psk-chapter title="Generic DID Syntax">
            The generic DID scheme is a URI scheme conformant with [RFC3986].
            The following is the ABNF definition using the syntax in [RFC5234], which defines ALPHA and DIGIT. All other rule names not defined in this ABNF are defined in [RFC3986].
        </psk-chapter>


        <psk-highlight title="Issue" type-of-highlight="issue">
            This document is undergoing a major structural refactoring and will not be easy to read. A previously published version that has a better topical flow may be a better read for people new to this work. When this document has been updated to have a better flow, this comment will be removed.
        </psk-highlight>

        The generic DID scheme is a URI scheme conformant with [RFC3986].
        <psk-highlight title="Note" type-of-highlight="note">
            A DID always identifies the DID subject.
        </psk-highlight>

    </psk-chapter>

    <psk-chapter title="DID Syntax">
        <psk-chapter title="Generic DID Syntax">
            The generic DID scheme is a URI scheme conformant with [RFC3986].
            The following is the ABNF definition using the syntax in [RFC5234], which defines ALPHA and DIGIT. All other rule names not defined in this ABNF are defined in [RFC3986].
        </psk-chapter>


        <psk-highlight title="Issue" type-of-highlight="issue">
            This document is undergoing a major structural refactoring and will not be easy to read. A previously published version that has a better topical flow may be a better read for people new to this work. When this document has been updated to have a better flow, this comment will be removed.
        </psk-highlight>

        The generic DID scheme is a URI scheme conformant with [RFC3986].
        <psk-highlight title="Note" type-of-highlight="note">
            A DID always identifies the DID subject.
        </psk-highlight>

    </psk-chapter>

    <psk-chapter title="DID Syntax">
        <psk-chapter title="Generic DID Syntax">
            The generic DID scheme is a URI scheme conformant with [RFC3986].
            The following is the ABNF definition using the syntax in [RFC5234], which defines ALPHA and DIGIT. All other rule names not defined in this ABNF are defined in [RFC3986].
        </psk-chapter>


        <psk-highlight title="Issue" type-of-highlight="issue">
            This document is undergoing a major structural refactoring and will not be easy to read. A previously published version that has a better topical flow may be a better read for people new to this work. When this document has been updated to have a better flow, this comment will be removed.
        </psk-highlight>

        The generic DID scheme is a URI scheme conformant with [RFC3986].
        <psk-highlight title="Note" type-of-highlight="note">
            A DID always identifies the DID subject.
        </psk-highlight>

    </psk-chapter>

    <psk-chapter title="DID Syntax">
        <psk-chapter title="Generic DID Syntax">
            The generic DID scheme is a URI scheme conformant with [RFC3986].
            The following is the ABNF definition using the syntax in [RFC5234], which defines ALPHA and DIGIT. All other rule names not defined in this ABNF are defined in [RFC3986].
        </psk-chapter>


        <psk-highlight title="Issue" type-of-highlight="issue">
            This document is undergoing a major structural refactoring and will not be easy to read. A previously published version that has a better topical flow may be a better read for people new to this work. When this document has been updated to have a better flow, this comment will be removed.
        </psk-highlight>

        The generic DID scheme is a URI scheme conformant with [RFC3986].
        <psk-highlight title="Note" type-of-highlight="note">
            A DID always identifies the DID subject.
        </psk-highlight>

    </psk-chapter>

    <psk-chapter title="DID Syntax">
        <psk-chapter title="Generic DID Syntax">
            The generic DID scheme is a URI scheme conformant with [RFC3986].
            The following is the ABNF definition using the syntax in [RFC5234], which defines ALPHA and DIGIT. All other rule names not defined in this ABNF are defined in [RFC3986].
        </psk-chapter>

        <psk-highlight title="Issue" type-of-highlight="issue">
            This document is undergoing a major structural refactoring and will not be easy to read. A previously published version that has a better topical flow may be a better read for people new to this work. When this document has been updated to have a better flow, this comment will be removed.
        </psk-highlight>

        The generic DID scheme is a URI scheme conformant with [RFC3986].
        <psk-highlight type-of-highlight="note">
            A DID always identifies the DID subject.
        </psk-highlight>

        <psk-chapter title="Generic DID Syntax with a very long and boring title">
            The generic DID scheme is a URI scheme conformant with [RFC3986].
            The following is the ABNF definition using the syntax in [RFC5234], which defines ALPHA and DIGIT. All other rule names not defined in this ABNF are defined in [RFC3986].
        </psk-chapter>

        <psk-chapter title="Generic DID Syntax with medium title">
            The generic DID scheme is a URI scheme conformant with [RFC3986].
            The following is the ABNF definition using the syntax in [RFC5234], which defines ALPHA and DIGIT. All other rule names not defined in this ABNF are defined in [RFC3986].
        </psk-chapter>

        <psk-chapter title="Generic DID Syntax with a very long and boring title that is never ending to tell you the story">
            The generic DID scheme is a URI scheme conformant with [RFC3986].
            The following is the ABNF definition using the syntax in [RFC5234], which defines ALPHA and DIGIT. All other rule names not defined in this ABNF are defined in [RFC3986].
        </psk-chapter>


    </psk-chapter>





</psk-page>
